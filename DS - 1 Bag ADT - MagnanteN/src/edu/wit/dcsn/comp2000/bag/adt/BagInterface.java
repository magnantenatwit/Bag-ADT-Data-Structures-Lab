/* @formatter:off * * Dave Rosenberg * Comp 2000 - Data Structures * Lab: Bag ADT * Fall, 2020 *  * Usage restrictions: *  * You may use this code for exploration, experimentation, and furthering your * learning for this course. You may not use this code for any other * assignments, in my course or elsewhere, without explicit permission, in * advance, from myself (and the instructor of any other course). *  * Further, you may not post nor otherwise share this code with anyone other than * current students in my sections of this course. Violation of these usage * restrictions will be considered a violation of the Wentworth Institute of * Technology Academic Honesty Policy. * * Do not remove this notice. * * @formatter:on */package edu.wit.dcsn.comp2000.bag.adt ;/** * An interface that describes the operations of a bag of objects. *  * @author Frank M. Carrano * @author Timothy M. Henry * @version 4.1 *  * @author David M Rosenberg * @version 4.2.0 2019-05-12 Reformatted and enhanced * @version 4.3.0 2020-08-08 restore to original functionality * @version 4.4.0 2020-09-13 move enhanced functionality back here as default methods. *  * @param <T> *     The class of items the Bag will hold. */public interface BagInterface<T>    {    /**     * Adds a new entry to this bag.     *      * @param newEntry     *     The object to be added as a new entry.     *      * @return {@code true} if the addition is successful, or {@code false} if     *     not.     */    public boolean add( T newEntry ) ;    /**     * Removes all entries from this bag.     */    public void clear() ;    /**     * Tests whether this bag contains a given entry.     *      * @param anEntry     *     The entry to locate.     *          * @return {@code true} if this bag contains {@code anEntry}, or     *     {@code false} if not.     */    public boolean contains( T anEntry ) ;        /**     * Creates a new bag of objects that would be left in this bag after     * removing those that also occur in {@code anotherBag}.     * <p>     * Note: the contents of {@code this} bag are unchanged.     *      * @param anotherBag     *     The bag containing objects to be removed.     *     <p>     *     Note: the contents of {@code anotherBag} are unchanged.     *      * @return a new, combined bag.     */    public default BagInterface<T> difference( BagInterface<T> anotherBag )        {        throw new UnsupportedOperationException() ;                }   // end default difference()        /**     * Gets the current number of entries in this bag.     *      * @return The integer number of entries currently in the bag.     */    public int getCurrentSize() ;    /**     * Counts the number of times a given entry appears in this bag.     *      * @param anEntry     *     The entry to be counted.     *      * @return The number of times {@code anEntry} appears in the bag.     */    public int getFrequencyOf( T anEntry ) ;        /**     * Creates a new bag that contains those objects that occur in both     * {@code this} bag and {@code anotherBag}.     * <p>     * Note: the contents of {@code this} bag are unchanged.     *      * @param anotherBag     *     The bag containing objects to be compared.     *     <p>     *     Note: the contents of {@code anotherBag} are unchanged.     *      * @return A new, combined bag.     */    public default BagInterface<T> intersection( BagInterface<T> anotherBag )        {        throw new UnsupportedOperationException() ;                }   // end default intersection()    /**     * Sees whether this bag is empty.     *      * @return {@code true} if the bag is empty, or {@code false} if not.     */    public boolean isEmpty() ;    /**     * Removes one unspecified entry from {@code this} bag, if possible.     *      * @return Either the removed entry, if the removal. was successful, or     *     {@code null}.     */    public T remove() ;    /**     * Removes one occurrence of a given entry from {@code this} bag.     *      * @param anEntry     *     The entry to be removed.     *      * @return {@code true} if the removal was successful, or {@code false} if     *     not.     */    public boolean remove( T anEntry ) ;    /**     * Retrieves all entries that are in this bag.     *      * @return A newly allocated array of all the entries in the bag.     *     <p>     *     Note: If the bag is empty, the returned array is empty.     */    public T[] toArray() ;    /**     * Creates a new bag that combines the contents of {@code this} bag and     * {@code anotherBag}.     * <p>     * Note: the contents of {@code this} bag are unchanged.     *      * @param anotherBag     *     The bag that is to be added.     *     <p>     *     Note: the contents of {@code anotherBag} are unchanged.     *      * @return A new, combined bag.     */    public default BagInterface<T> union( BagInterface<T> anotherBag )        {        throw new UnsupportedOperationException() ;                }   // end default union()    } // end interface BagInterface