/* @formatter:off * * Dave Rosenberg * Comp 2000 - Data Structures * Lab: Bag ADT * Fall, 2020 * * Usage restrictions: * * You may use this code for exploration, experimentation, and furthering your * learning for this course. You may not use this code for any other * assignments, in my course or elsewhere, without explicit permission, in * advance, from myself (and the instructor of any other course). * * Further, you may not post nor otherwise share this code with anyone other than * current students in my sections of this course. Violation of these usage * restrictions will be considered a violation of the Wentworth Institute of * Technology Academic Honesty Policy. * * Do not remove this notice. * * @formatter:on *//* @formatter:off * * You must: *  - replace "Your Name" with your actual name in the class Javadoc comment block *  - change each entire "// TODO..." comment to "// DONE" *      - your code must follow the comment *  - follow my coding style *      - see Appendix A in the textbook for the basics *      - qualify all instance variable references with 'this.' *          - for example, this.numberOfEntries rather than numberOfEntries *          - I don't typically qualify instance method invocations with 'this.' *              - exception: I'm manipulating two or more instances in a method *      - braces are required for single-line statements *          - for example: *              if ( condition ) *                  { *                  return true ; *                  } *          - I use/require next-line, indented brace position (as above) *      - fully spell out your variable, parameter, method, class names * *  You may not: *  - use any Java Class Library (JCL) classes or methods other than: *      StringBuilder - in toString() to construct the output String *          - you may construct and use Strings for output but you aren't *              permitted to use any String methods *      Arrays - you need to instantiate and manipulate arrays in toArray() *              but you aren't permitted to use any Array/Arrays methods * * You should: *  - find the appropriate code in the textbook and copy it (do not attribute) *  - the array constructor, cloning constructor, difference(), intersection(), *      and union() are not in the book - they are described in the assignment *      and the Javadoc comments * * @formatter:on */package edu.wit.dcsn.comp2000.bag.adt ;import edu.wit.dcsn.comp2000.common.Node ;/** * A class of bags whose entries are stored in a chain of linked nodes. The bag is * never full. * * @author Frank M. Carrano * @author Timothy M. Henry * @version 4.1 * @author David M Rosenberg * @version 4.2.0 2016-01-10 Reformat and revise * @version 4.3.0 2019-05-12 Add 'cloning' constructor, difference(), intersection(), *     union() * @version 4.4.0 2019-05-24 standardize on resultBag for returned construct variable *     name for difference(), intersection(), union() * @version 4.5.0 2020-01-28 *     <ul> *     <li>add constructor taking array of entries *     <li>move Node to a separate class *     </ul> * @version 4.6.0 2020-05-14 *     <ul> *     <li>update comments *     <li>change stub value from 0 to -1 in getCurrentSize() and getFrequencyOf() *     <li>change stub value to null for reference methods *     </ul> * @author Nicholas Magnante // DONE replace with your actual name (not username) * @version 4.7.0 2020-09-14 implementation per assignment * @param <T> *     The class of items the {@code LinkedBag} will hold. */public final class LinkedBag<T> implements BagInterface<T>    {    /*     * instance variables     */    private Node<T> firstNode ;     // reference to first node    private int numberOfEntries ;   // count of entries in use    /*     * constructors     */    /**     * Initialize a new, empty LinkedBag     */    public LinkedBag()        {        // initialize the bag - state is empty        initializeState() ;        }	// end no-arg constructor    /**     * Initialize a new LinkedBag and populate it with the contents of     * {@code sourceBag}     *     * @param sourceBag     *     another bag containing zero or more entries to copy to the newly     *     instantiated LinkedBag     *     <p>     *     Note: {@code sourceBag} is an instance of any class that implements     *     {@code BagInterface} - it doesn't have to be another {@code LinkedBag}     *     <p>     *     Note: the contents of {@code sourceBag} are unchanged.     */    public LinkedBag( final BagInterface<T> sourceBag )        {        this() ;	// known valid starting state: empty        if ( sourceBag != null )            {            final T[] sourceBagContents = sourceBag.toArray() ;            for ( final T i : sourceBagContents )                {                this.add( i ) ;                }            }        // DONE implement the rest of this        }	// end 1-arg 'cloning' constructor    /**     * Initialize a new LinkedBag and populate it with the contents of     * {@code initialContents}     *     * @param initialContents     *     an array of zero or more entries to copy to the newly instantiated     *     {@code LinkedBag}     *     <p>     *     Note: the contents of {@code initialContents} are unchanged.     */    public LinkedBag( final T[] initialContents )        {        // DONE implement this        if ( initialContents != null )            {            for ( final T i : initialContents )                {                this.add( i ) ;                }            }        }	// end 1-arg 'array' constructor    /*     * public LinkedBag API methods     */    /**     * Adds a new entry to this bag.     *     * @param newEntry     *     The object to be added as a new entry.     * @return {@code true} if the addition is successful, or {@code false} if not.     */    @Override    public boolean add( final T newEntry )        {        if ( newEntry == null )            {            throw new IllegalArgumentException( "entry cannot be null" ) ;            }        final Node<T> newNode = new Node<>( newEntry ) ;        newNode.setNextNode( this.firstNode ) ;        this.firstNode = newNode ;        this.numberOfEntries++ ;        // DONE implement this        return true ;      // DONE this is stub value - replace with actual/correct                           // value        }	// end add()    /**     * Removes all entries from this bag.     */    @Override    public void clear()        {        // re-initialize the state to empty        initializeState() ;        while ( !isEmpty() )            {            remove() ;            }        }	// end clear()    /**     * Tests whether this bag contains a given entry.     *     * @param anEntry     *     The entry to locate.     * @return {@code true} if this bag contains {@code anEntry}, or {@code false} if     *     not.     */    @Override    public boolean contains( final T anEntry )        {        // DONE implement this        boolean found = false ;        Node<T> currentNode = this.firstNode ;        while ( !found && ( currentNode != null ) && ( anEntry != null ) )            {            if ( anEntry.equals( currentNode.getData() ) )                {                found = true ;                }            else                {                currentNode = currentNode.getNextNode() ;                }            }        return found ;      // DONE this is stub value - replace with actual/correct                            // value        }	// end contains()    /**     * Creates a new bag of objects that would be left in this bag after removing     * those that also occur in {@code anotherBag}.     * <p>     * Note: the contents of {@code this} bag are unchanged.     *     * @param anotherBag     *     The bag containing objects to be removed.     *     <p>     *     Note: the contents of {@code anotherBag} are unchanged.     * @return a new, combined bag.     */    @Override    public BagInterface<T> difference( final BagInterface<T> anotherBag )        {        // TODO implement this        final LinkedBag<T> ans = new LinkedBag<>() ;        final T[] arr = this.toArray() ;        if ( anotherBag != null )            {            for ( final T i : arr )                {                if ( !anotherBag.contains( i ) )                    {                    ans.add( i ) ;                    }                else if ( ( anotherBag.getFrequencyOf( i ) <                            this.getFrequencyOf( i ) ) &&                          ( !ans.contains( i ) ) )                    {                    ans.add( i ) ;                    }                }            }        else            {            for ( final T i : arr )                {                ans.add( i ) ;                }            }        return ans ;      // DONE this is stub value - replace with actual/correct                          // value        }   // end difference()    /**     * Gets the current number of entries in this bag.     *     * @return The integer number of entries currently in the bag.     */    @Override    public int getCurrentSize()        {        // DONE implement this        return this.numberOfEntries ;     // DONE this is stub value - replace with                                          // actual/correct value        }	// end getCurrentSize()    /**     * Counts the number of times a given entry appears in this bag.     *     * @param anEntry     *     The entry to be counted.     * @return The number of times {@code anEntry} appears in the bag.     */    @Override    public int getFrequencyOf( final T anEntry )        {        // DONE implement this        int frequency = 0 ;        int counter = 0 ;        Node<T> currentNode = this.firstNode ;        while ( ( counter < this.numberOfEntries ) && ( currentNode != null ) &&                ( anEntry != null ) )            {            if ( anEntry.equals( currentNode.getData() ) )                {                frequency++ ;                }            counter++ ;            currentNode = currentNode.getNextNode() ;            }        return frequency ;     // DONE this is stub value - replace with                               // actual/correct value        }	// end getFrequencyOf()    /**     * Creates a new bag that contains those objects that occur in both {@code this}     * bag and {@code anotherBag}.     * <p>     * Note: the contents of {@code this} bag are unchanged.     *     * @param anotherBag     *     The bag containing objects to be compared.     *     <p>     *     Note: the contents of {@code anotherBag} are unchanged.     * @return A new, combined bag.     */    @Override    public BagInterface<T> intersection( final BagInterface<T> anotherBag )        {        // TODO implement this        final LinkedBag<T> ans = new LinkedBag<>() ;        if ( anotherBag != null )            {            final T[] firstArr = this.toArray() ;            final T[] secArr = anotherBag.toArray() ;            for ( final T i : firstArr )                {                if ( anotherBag.contains( i ) && !ans.contains( i ) )                    {                    ans.add( i ) ;                    }                else if ( anotherBag.getFrequencyOf( i ) >=                          this.getFrequencyOf( i ) )                    {                    ans.add( i ) ;                    }                }            for ( final T i : secArr )                {                if ( this.contains( i ) && !ans.contains( i ) )                    {                    ans.add( i ) ;                    }                }            }        return ans ;     // TODO this is stub value - replace with actual/correct                         // value        }   // end intersection()    /**     * Sees whether this bag is empty.     *     * @return {@code true} if the bag is empty, or {@code false} if not.     */    @Override    public boolean isEmpty()        {        // DONE implement this        if ( this.numberOfEntries == 0 )            {            return true ;            }        return false ;      // DONE this is stub value - replace with actual/correct                            // value        }	// end isEmpty()    /**     * Removes one unspecified entry from {@code this} bag, if possible.     *     * @return Either the removed entry, if the removal. was successful, or     *     {@code null}.     */    @Override    public T remove()        {        T result = null ;        if ( this.firstNode != null )            {            result = this.firstNode.getData() ;            this.firstNode = this.firstNode.getNextNode() ;            this.numberOfEntries-- ;            }        // DONE implement this        return result ;       // DONE this is stub value - replace with                              // actual/correct value        }	// end no-arg remove()    /**     * Removes one occurrence of a given entry from {@code this} bag.     *     * @param anEntry     *     The entry to be removed.     * @return {@code true} if the removal was successful, or {@code false} if not.     */    @Override    public boolean remove( final T anEntry )        {        // DONE implement this        boolean result = false ;        final Node<T> nodeN = getReferenceTo( anEntry ) ;        if ( nodeN != null )            {            nodeN.setData( this.firstNode.getData() ) ;            this.firstNode = this.firstNode.getNextNode() ;            this.numberOfEntries-- ;            result = true ;            }        return result ;     // DONE this is stub value - replace with actual/correct                            // value        }	// end 1-arg remove()    /**     * Retrieves all entries that are in this bag.     *     * @return A newly allocated array of all the entries in the bag.     *     <p>     *     Note: If the bag is empty, the returned array is empty.     */    @Override    public T[] toArray()        {        // DONE implement this        @SuppressWarnings( "unchecked" )        final T[] result = (T[]) new Object[ this.numberOfEntries ] ;        int index = 0 ;        Node<T> currentNode = this.firstNode ;        while ( ( index < this.numberOfEntries ) && ( currentNode != null ) )            {            result[ index ] = currentNode.getData() ;            index++ ;            currentNode = currentNode.getNextNode() ;            }        return result ;     // DONE this is stub value - replace with actual/correct                            // value        }	// end toArray()    /*     * (non-Javadoc)     * @see java.lang.Object#toString()     */    @Override    public String toString()        {        /*         * we'll build a string of comma-separated text representations of each entry         * and surround them with square brackets         */        final StringBuilder resultingString = new StringBuilder() ;        int index = 0 ;        Node<T> currentNode = this.firstNode ;        resultingString.append( "[" ) ;        while ( ( index < this.numberOfEntries ) && ( currentNode != null ) )            {            resultingString.append( currentNode.getData() + ", " ) ;            index++ ;            currentNode = currentNode.getNextNode() ;            }        if ( resultingString.length() > 1 )            {            resultingString.deleteCharAt( resultingString.length() - 1 ) ;            resultingString.deleteCharAt( resultingString.length() - 1 ) ;            }        resultingString.append( "]" ) ;        // DONE implement this        return resultingString.toString() ;     // DONE this is stub value - replace                                                // with actual/correct value        }	// end toString()    /**     * Creates a new bag that combines the contents of {@code this} bag and     * {@code anotherBag}.     * <p>     * Note: the contents of {@code this} bag are unchanged.     *     * @param anotherBag     *     The bag that is to be added.     *     <p>     *     Note: the contents of {@code anotherBag} are unchanged.     * @return A new, combined bag.     */    @Override    public BagInterface<T> union( final BagInterface<T> anotherBag )        {        // DONE implement this        final LinkedBag<T> ans = new LinkedBag<>() ;        final T firstArr[] = this.toArray() ;        for ( final T i : firstArr )            {            ans.add( i ) ;            }        if ( anotherBag != null )            {            final T secArr[] = anotherBag.toArray() ;            for ( final T i : secArr )                {                ans.add( i ) ;                }            }        return ans ;     // DONE this is stub value - replace with actual/correct                         // value        }   // end union()    // end of LinkedBag API methods    /*     * private utility methods     */    /**     * Utility method to load this bag with the provided contents     *     * @param contents     *     the items to add     *     <ul>     *     <li>array will never be {@code null}     *     <li>{@code add( entry )} will prevent adding {@code null} entries     *     </ul>     */    private void add( final T[] contents )        {        // OPTIONAL implement this        }   // end add() from array    /**     * Find a node in the chain with data that matches the parameter.     *     * @param anEntry     *     the entry to match     * @return a reference to a node containing a matching entry or {@code null} if     *     not found     */    private Node<T> getReferenceTo( final T anEntry )        {        // DONE implement this        boolean found = false ;        Node<T> currentNode = this.firstNode ;        if ( anEntry == null )            {            return null ;            }        while ( !found && ( currentNode != null ) )            {            if ( anEntry.equals( currentNode.getData() ) )                {                found = true ;                }            else                {                currentNode = currentNode.getNextNode() ;                }            }        return currentNode ;     // DONE this is stub value - replace with                                 // actual/correct value        }	// end getReferenceTo()    /**     * Initialize the state of the current {@code LinkedBag} to empty     */    private void initializeState()        {        // DONE implement this        this.firstNode = null ;        this.numberOfEntries = 0 ;        }	// end initializeState()    /**     * (optional) test driver for LinkedBag     *     * @param args     *     -unused-     */    public static void main( final String[] args )        {        // OPTIONAL for debugging/testing        }	// end main()    }	// end class LinkedBag